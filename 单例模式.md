# 单例模式

## 定义

保证一个类只有一个实例，并提供一个全局访问点

## 适用场景

* 想确保任何情况下只有一个实例

## 优点

* 内存中只有一个实例，减少了内存开销

* 可以避免对资源的多重占用

* 设置全局访问点，严格控制访问

## 缺点

* 没有接口，扩展困难

## UML

![单例模式UML](https://ws1.sinaimg.cn/large/7ebba446gy1fysao73xncj20pc0hgwfq.jpg)

## 单例模式的几种方式

### 懒汉式


上面的懒汉式单例模式如果是单线程调用时没问题的，如果是多线程的话是有线程安全问题的，具体的代码和测试请看类：
com.yashon.design.creational.single.LazySingleton

com.yashon.design.creational.single.LazySingletonTest

## 在类上加同步解决懒汉式线程安全问题

对于上面的线程安全问题，可以在类上加synchronized关键字来同步，这样的话就会有一个性能问题，synchronized关键字有可能影响性能问题，具体的代码和测试如下：

com.yashon.design.creational.single.SynchronizedClassLazySingleton

com.yashon.design.creational.single.SynchronizedClassLazySingletonTest

## 双重double check来解决性能问题和线程安全问题

针对上面的线程安全问题和性能问题，可以使用double check的方式来解决，即在方法代码块中增加synchronized关键字，这样的话就不用在整个方法上加同步，响应的就会提高一些性能问题，具体代码和测试如下：

com.yashon.design.creational.single.DoubleCheckSingleton

com.yashon.design.creational.single.DoubleCheckSingletonTest

## 内部类实现方式

上面虽然解决了问题，但是相应的也带来了另一个问题：重排序，可以使用volatile关键在来解决，但是也可以使用内部类的方式来解决,具体代码和测试如下：

com.yashon.design.creational.single.InnerClassSingleton

com.yashon.design.creational.single.InnerClassSingletonTest

## 饿汉式

以上的几种都是懒汉式，即在使用的时候才会初始化，而饿汉式是在类加载的时候就初始化了，调用的时候就直接返回了，具体代码和测试如下：

com.yashon.design.creational.single.HungarySingleton

com.yashon.design.creational.single.HungarySingletonTest